#include <stdlib.h>

// 指定された単一の文字(c)が、ある文字セット(charset)に含まれているかどうかチェックするプログラム
int is_in_charset(char  c, char *charset)
{
    while(*charset)
    {
        if (c == *charset)
            return (1);
        charset++;
    }
    return (0);
}

int get_word_count(char*str, char* charset)
{
    int count = 0;

    while (*str)
    {
        while (*str && is_in_charset(*str, charset))
            str++;
        if (*str && !is_in_charset(*str, charset))
        {
            count += 1;
            while (*str && !is_in_charset(*str, charset))
                str++;
        }
    }
    return (count);
}

char* alloc_word(char* start, char* end)
{
    char    *word;
    int i;

    i = 0;
    word = (char*)malloc(sizeof(char) * (end - start + 1));
    if (word == NULL)
        return (NULL);
    while (start < end)
    {
        word[i] = *start;
        i++;
        start++;
    }
    word[i] = '\0';
    return (word);
}

void    split_word(char** result, char *str, char *charset)
{
    char *start;
    int i;

    i = 0;
    while (*str)
    {
        while (*str && is_in_charset(*str, charset))
            str++;
        start = str;
        while (*str && !is_in_charset(*str, charset))
            str++;
        if (str > start)
        {
            result[i] = alloc_word(start, str);
            i++;
        }
    }
    result[i] = NULL;
}

char    **ft_split(char *str, char *charset)
{
    char    **result;
    int word_count;
    
    word_count = get_word_count(str, charset);
    result = (char **)malloc(sizeof(char *) * (word_count + 1));
    if (result == NULL)
        return (NULL);
    split_word(result, str, charset);
    return (result);
}

#include <stdio.h>
int	main(void)
{
	char	a[] = "test,/test1, test2,test3, test4";
	char	sep[] = ", /";
	char	**p;
	int		count;
	p = ft_split(a, sep);
	count = get_word_count(a, sep);
	for (int i = 0; i < count ; i++)
	{
		printf("%d: %s\n", i, p[i]);
	}
	return (0);
}

/* ** is_in_charsetの説明
動作の詳細
関数は2つのパラメータを受け取ります：
チェックする単一の文字cと、文字セットを表す文字列へのポインタcharset。
charsetが指す文字列を最初から順に走査（スキャン）します。

この走査は、charsetの各文字に対して行われ、文字列の終端（ヌル文字\0が現れる点）
に到達するまで続けられます。
各ステップで、charsetの現在の文字がcと一致するかどうかをチェックします。

一致する場合は、関数はすぐに1を返して終了します。
これは、指定された文字が文字セット内に見つかったことを意味します。

文字セットの全ての文字に対してチェックを行った後、もしcが見つからなければ、
関数は0を返します。これは、指定された文字が文字セット内に存在しないことを意味します。
使用例
この関数は、例えばテキスト処理やパーサーなど、
特定の文字セット（区切り文字、特殊記号、アルファベットなど）
を識別したい場面で役立ちます。文字が特定のグループに属するかどうかを
判断する必要がある場合に使用できます。

一言で言い表すと
このプログラムは、
「指定された文字が与えられた文字セットに含まれているかをチェックする関数」と言えます。
*/

/*ダブルポインタ　char** の説明: char **は、文字列へのポインタが格納された箱（配列）へのポインタ

ポインタのポインタ、つまりchar **が「文字列へのポインタの配列へのポインタ」
となる理由を、小学生にもわかるように説明してみましょう。

基本から始めましょう
ポインタとは: ポインタとは、ある場所（メモリ上のアドレス）を指し示すものです。
例えば、あなたが宝探しで「宝の地図」を持っているとします。この地図がポインタです。
地図（ポインタ）は宝（データ）がどこにあるのかを示しています。

文字列とポインタ: 文字列は、文字の連続です。
C言語では、文字列の最初の文字の場所（アドレス）を指し示すポインタを使って、
その文字列を表します。この場合、地図（ポインタ）は文字列の
「始まりの場所」を示しており、そこから文字の連続（文字列）をたどることができます。

ポインタのポインタ
ポインタのポインタとは: では、「ポインタのポインタ」とは何でしょうか？
これは「地図の地図」のようなものです。つまり、地図への道順を示す地図です。
この「地図の地図」は、最終的に宝ではなく、宝の地図がどこにあるかを教えてくれます。
char **の場合
文字列へのポインタの配列: さて、複数の宝（文字列）があるとしましょう。
各宝の地図（文字列へのポインタ）を一つずつ持っていると、それらをまとめて保管したいですよね。

そこで、これらの地図を一つの箱（配列）に入れることにします。
この箱は「文字列へのポインタの配列」となります。箱の中には複数の地図があり、
それぞれの地図が異なる宝の場所を指し示しています。

char **とは: では、この「文字列へのポインタの配列」をどうやって指し示すかというと、
それには「箱への地図」、つまりポインタのポインタが必要です。

この「箱への地図」がchar **になります。char **は、
文字列へのポインタが格納された箱（配列）へのポインタです。
つまり、char **は「文字列へのポインタの配列」を指し示すポインタです。

まとめ
char **は、「複数の文字列の場所を示す地図（ポインタ）が入った箱への地図」です。
この「箱への地図」を使って、箱の中にある各地図を取り出し、
その地図が示す場所にある宝（文字列）を見つけることができます。

このように考えると、char **が「文字列へのポインタの配列へのポインタ」となる理由が
少し理解しやすくなるかもしれません。
*/

/* Split_word関数の処理の流れ説明

以下に、プログラムの動作を正確に表現するための説明を補足します。

startの役割: startは文字列strの特定の位置を指すポインタであり、
単語の開始位置を保持します。プログラムの開始時にstartを初期化するわけではありませんが、
区切り文字をスキップした後の最初の文字（単語の開始）を指すように設定されます。

最初のwhile文: このループはstrが指す文字がヌル文字
（つまり、文字列の終わりを示す特殊な文字）に到達するまで続きます。
これにより、文字列全体が走査されます。

区切り文字のスキップ: 最初の内側のwhileループで、
strは区切り文字を見つけるたびにインクリメントされ、
これにより区切り文字をスキップします。
このステップの後、strは単語の最初の文字を指しています。

startへの代入: startにstrの現在の値（単語の最初の文字のアドレス）を代入します。
これは、単語の抽出を開始する位置を記録するためです。

単語の終了までの走査: 次の内側のwhileループで、
strは区切り文字でない間インクリメントされ続け、単語の終わりまで進みます。
このループが完了すると、strは次の区切り文字の位置または文字列の終端を指しています。

単語の抽出と格納: if (str > start)の条件は、
strとstartの間に少なくとも1文字がある場合に真となります
（つまり、空の単語がないことを保証します）。
この条件が真の場合、alloc_word関数を呼び出して
startからstrの直前までの文字列を新たにメモリに確保し、
そのメモリ領域へのポインタをresult[i]に格納します。
そして、iをインクリメントして、次の単語を格納する位置を準備します。

終了の処理: 全ての単語が処理された後、
result配列の最後の要素にNULLを代入して、
配列の終わりを明示的に示します。

以上の説明で、split_words関数の動作と、
それがどのようにして文字列を区切り文字で分割し、
結果を配列に格納するかについての理解が深まったことを願っています。
*/