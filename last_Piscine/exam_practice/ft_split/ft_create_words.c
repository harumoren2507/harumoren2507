int *ft_create_word(char *str, int i, int j)
{
    char *word;
    int o;

    o = 0;
    
        word = (char *)malloc(sizeof(char) * (j - i));
        if (word == 'NULL')
        {
            return 'NULL';
            // メモリ確保に失敗した場合、NULL を返す
        }
        while (i < j)
        {
            word[o] = str[i];
            i++;
            o++;
        }
        word[o] = '\0';
        return (word);
    }

char	*create_word(char *str, int i, int j)
{
	char	*word;
	int		o;

	o = 0;
	if ((word = (char *)malloc(sizeof(char) * (j - i))) == ((void *)0))
		return ((void *)0);
	while (i < j)
	{
		word[o] = str[i];
		i++;
		o++;
	}
	word[o] = '\0';
	return (word);
}


/*　★　プログラム概要
このcreate_word関数は、文字列から特定の範囲の文字を取り出して、新しい文字列（単語）を作るためのものです。
この関数は、大きな文字列（str）、取り出し始める位置（i）、そして取り出しを終える位置（j）を引数として受け取ります。
作業の結果として、範囲内の文字だけを含む新しい文字列を返します。

処理の流れと各部の意味
メモリの確保:

malloc関数を使用して、新しい文字列（単語）のためのメモリ空間を確保します。
必要なメモリのサイズは(j - i)です。これは、取り出す範囲の文字数に相当します。
ただし、文字列の終端を示すための'\0'も必要なので、
実際にはmalloc(sizeof(char) * (j - i + 1))として1文字分多く確保する必要があります（このコードにはその修正が必要です）。

もしメモリ確保に失敗したら、NULL（((void *)0)）を返して、エラーを示します。
文字のコピー:

whileループを使って、strのi番目からj-1番目までの文字を、新しく確保したメモリ空間（word）にコピーします。
oは新しい文字列（word）のインデックスを追跡するために使用され、iは元の文字列（str）のインデックスです。
ループの各ステップで、str[i]の文字をword[o]にコピーし、両方のインデックスを1増やします。
文字列の終端:

ループが終わったら、新しい文字列の最後に'\0'（ヌル文字）を追加して、
文字列の終わりを示します。これにより、wordは正しいC文字列となります。
結果の返却:

最後に、新しく作成した文字列（word）のポインタを返します。
注意点
このコードには、mallocで確保するメモリのサイズが実際には1文字分足りないという小さな問題があります。malloc(sizeof(char) * (j - i + 1))とすることで、文字列の終端を示す'\0'のためのスペースも確保する必要があります。
mallocがNULLを返す可能性に対処するため、関数を使う側では返されたポインタをチェックして、エラー処理を行うことが重要です。
この関数により、大きな文字列から小さな部分文字列を安全に取り出し、それを扱いやすい形で利用することができます。
*/
/*　★　取り出し始める位置について
ft_split関数内で取り出す範囲を決める処理は、文字列strを走査して区切り文字（charsetに含まれる文字）に遭遇する部分で行われます。具体的には、以下のステップでこの範囲が決定されます。

ステップ1: 文字列の走査開始
ft_split関数は、引数として与えられた文字列strを最初から最後まで一文字ずつ走査します。
ステップ2: 単語の開始位置の検出
走査中、区切り文字でない文字（単語の一部）を見つけた場合、その文字の位置（iとして参照される）が単語の開始位置としてマークされます。この時点で、ft_is_space関数が区切り文字かどうかを判断します。
走査が続けられ、区切り文字に遭遇するまでの間、単語の一部と見なされる文字が連続します。
ステップ3: 単語の終了位置の検出
区切り文字に遭遇したら、その直前の文字が単語の終了位置（jとして参照される）です。この位置は、単語を形成する最後の文字の次の位置を指します。
ステップ4: 単語の抽出
単語の開始位置iと終了位置jが決定されたら、create_word関数を使用して、その範囲にある文字を新しい文字列として抽出（コピー）します。この関数は、iからj-1までの文字を新しいメモリ領域にコピーし、終端文字'\0'を追加して、単語を表す新しい文字列を形成します。
ステップ5: 次の単語へ
一つの単語を抽出した後、ft_split関数は文字列の残りの部分に対して同じプロセスを繰り返し、全ての単語が抽出されるまでこの処理を続けます。
まとめ
ft_split関数では、引数として与えられたcharset内の区切り文字を基準にして、文字列str内の単語の開始位置と終了位置を動的に決定します。このプロセスにより、文字列を単語に分割し、それぞれの単語を新しい文字列としてメモリに確保して返すことができます。
*/