/*
(octet >> 0) = 11101010
    & 1      = 00000001
*/

unsigned char   reverse_bits(unsigned char byte)
{
        return  (((byte >> 0) & 1) << 7)|\
                (((byte >> 1) & 1) << 6)|\
                (((byte >> 2) & 1) << 5)|\
                (((byte >> 3) & 1) << 4)|\
                (((byte >> 4) & 1) << 3)|\
                (((byte >> 5) & 1) << 2)|\
                (((byte >> 6) & 1) << 1)|\
                (((byte >> 7) & 1) << 0);
}


/*解説

元のビット列
元のビット列: 0100 0001
ステップごとの解説
最下位ビットから順に処理

関数は、最下位ビット（LSB）から最上位ビット（MSB）まで、
各ビットを右シフトして1ビットだけ取り出し、そのビットを適切な位置に左シフトして配置します。
各ビットを右にシフトしてAND演算 (>> と & 1):

(octet >> 0) & 1: 最下位ビット（1）を取り出し、1とAND演算。結果は1です。
(octet >> 1) & 1: 1ビット右にシフト（0）してから、1とAND演算。結果は0です。
(octet >> 2) & 1: 2ビット右にシフト（0）してから、1とAND演算。結果は0です。
(octet >> 3) & 1: 3ビット右にシフト（0）してから、1とAND演算。結果は0です。
(octet >> 4) & 1: 4ビット右にシフト（1）してから、1とAND演算。結果は1です。
(octet >> 5) & 1: 5ビット右にシフト（0）してから、1とAND演算。結果は0です。
(octet >> 6) & 1: 6ビット右にシフト（0）してから、1とAND演算。結果は0です。
(octet >> 7) & 1: 7ビット右にシフト（0）してから、1とAND演算。結果は0です。
左シフトして新しい位置に配置 (<<):

各ビットを取り出した後、それを逆の位置に配置します。例えば、最下位ビットは7ビット左にシフトして最上位ビットに、1ビット目は6ビッ ト左にシフトして2番目に上位のビットに配置されます。
ビットの組み合わせ (|):

最終的に、これらのシフトされたビットをビット単位のOR演算（|）で組み合わせて、反転されたバイトを形成します。
結果
最終的なビット列: 1000 0010



★二個目の疑問
(((octet >> 0) & 1) << 7)でoctetのbyteが上書きされて(((octet >> 1) & 1) << 6)は
それを引き継ぐなんてことはないのですか？

いいえ、そのようなことはありません。
この関数内でのoctetの値は上書きされたり変更されたりしません。
それぞれのステップでoctetからビットを抽出して操作するとき、

octetの元の値は保持されたままです。
各操作はoctetのコピー上で行われると考えると理解しやすいかもしれません。

処理の説明
**(((octet >> 0) & 1) << 7)**では、
octetの最下位ビットを取り出して、7ビット左にシフトします。
この操作により、最下位ビットが最上位ビットに移動します。
この時点でoctetの値には何の変更も加えられません。

**(((octet >> 1) & 1) << 6)**では、再び元のoctetの値から、
1ビット目を取り出して6ビット左にシフトします。
ここでもoctetの元の値は変更されず、先ほどの操作とは独立しています。
このプロセスはoctetの各ビットに対して繰り返されますが、
各操作は元のoctetの値を参照して実行され、octet自体を変更することはありません。


疑問3  |\について

ビット単位のOR演算（|）は、二つの数値の各ビットを比較し、
少なくとも一方のビットが1であれば、結果のそのビット位置を1にします。

両方のビットが0の場合のみ、結果のそのビット位置は0になります。
この演算を使って、ビットの組み合わせや設定を行うことができます。

具体的な例

1000 0000 | 0100 0000 = 1100 0000


\（バックスラッシュ）：この記号は、C言語における行の継続文字です。
ソースコード上で物理的に長い行を複数行に分けて書く際に使用され、コードの可読性を高めるために役立ちます。
この場合、\は次の行も現在の行の続きであることを意味しており、コンパイラはこれらを1行として扱います。
*/

/*補足解説
ビットシフト（シフト演算）は、コンピュータのプログラミングにおいて、
ビット列（数字の二進数表現）を左または右に移動させる操作のことを指します。
これにより、数値の乗算や除算を効率的に行うことができたり、
特定のビット操作を行うことができます。

シフト演算の種類
シフト演算には主に2種類あります：

左シフト（Left Shift）：<<記号で表され、
ビット列を左に指定されたビット数だけ移動させます。
左シフトすると、空いたビットは0で埋められます。
数値に対して左シフトを行うと、基本的にその数値を2のべき乗倍します
（例：x << 1はxを2倍、x << 2はxを4倍します）。

右シフト（Right Shift）：>>記号で表され、
ビット列を右に指定されたビット数だけ移動させます。
右シフトには2種類あります：

論理右シフト（Logical Right Shift）：
空いたビットは0で埋められます。数値に対して論理右シフトを行うと、
その数値を2のべき乗で割った結果になります。

算術右シフト（Arithmetic Right Shift）：
符号付き整数に使われ、空いたビットは最上位ビット（符号ビット）のコピーで埋められます。
これにより、正の数は0で埋められ、負の数は1で埋められます。
算術右シフトも数値を2のべき乗で割った結果になりますが、符号を保持します。
*/

/*問題原文
Assignment name  : reverse_bits
Expected files   : reverse_bits.c
Allowed functions:
--------------------------------------------------------------------------------

Write a function that takes a byte, reverses it, bit by bit (like the
example) and returns the result.

Your function must be declared as follows:

unsigned char   reverse_bits(unsigned char octet);

Example:

  1 byte
_____________
 0010  0110
         ||
         \/
 0110  0100

*/