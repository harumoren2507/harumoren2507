#include <unistd.h>

void    ft_putstr(char *str)
{
    while (*str)
        write(1, str++, 1);
}

void    ft_wdmatch(char *str1, char *str2)
{
    int i;
    int j;

    i = 0;
    j = 0;
    while (str1[i] && str2[j]) // str2を最後までループし、str1の文字が見つかるかチェック
    {
        if (str1[i] == str2[j])
            i++;
        j++;
    }
    if (!str1[i]) // str1のすべての文字が見つかった場合
        ft_putstr(str1); // str1を表示
}

int     main(int argc, char **argv)
{
    if (argc == 3)
        ft_wdmatch(argv[1], argv[2]); // argv[1]とargv[2]の全文字列を渡す
    ft_putstr("\n");
    return (0);
}

/*
この問題の仮想examはバグってる可能性がある
*/


/*
*このプログラムは、2つの文字列を引数として受け取り、
第一の文字列が第二の文字列に含まれる文字だけを使って、
元の順序を保持したまま作成できるかどうかを判断します。

もし第一の文字列が第二の文字列の文字を使って、
その順序を維持しながら作成できる場合、その第一の文字列を表示します。

そうでなければ、何も表示せずに新しい行に移ります。
このプログラムは、特に文字列の一致と順序の維持に焦点を当てています。

プログラムの動作
プログラムは2つの引数（文字列）をコマンドラインから受け取ります。

第一の文字列の各文字について、第二の文字列を検索し、
その文字が見つかった場合は、第一の文字列の次の文字に進みます。
このとき、第二の文字列の検索を続ける位置は、見つかった文字の次の位置からになります。

第一の文字列の全ての文字が第二の文字列内で見つかり、
かつ順序も保持されている場合、第一の文字列を出力します。

引数の数が2ではない場合、または第一の文字列が第二の文字列によって形成されない場合は、
何も表示せずに新しい行に移ります。

*例
実行例1: ./wdmatch "faya" "fgvvfdxcacpolhyghbreda" の場合、faya は fgvvfdxcacpolhyghbreda に含まれる文字だけを使って、その順序を維持しながら作成できるため、faya が表示されます。
実行例2: ./wdmatch "faya" "fgvvfdxcacpolhyghbred" の場合、faya は fgvvfdxcacpolhyghbred に含まれる文字を使って順序を維持しながら作成できないため、何も表示されません。

*プログラムのコード解説
ft_putstr 関数は、文字列を標準出力に表示する関数です。

ft_wdmatch 関数は、2つの文字列を受け取り、
第一の文字列が第二の文字列の文字だけを使って作成できるかどうかをチェックします。
この関数内で、第一の文字列の各文字が第二の文字列内で見つかるかどうかを順番にチェックし、
全ての文字が見つかれば第一の文字列を表示します。

main 関数では、引数の数が2であるかをチェックし、条件を満たす場合に限りft_wdmatch関数を呼び出します。
条件を満たさない場合や、ft_wdmatch関数の実行後は、新しい行を表示します。
このプログラムはC言語の基本的な概念、特にポインタ操作と文字列処理に関連しています。
*/


/* str1[i] && str2[j]について
str1[i] && str2[j]とはどういう意味でしょうか？　
str1[i] || str2[j]との違いを教えてください。

このコードの条件 str1[i] && str2[j] における && は、論理AND演算子です。
この条件は、「str1 の i 番目の文字が存在し（つまり、ヌル文字でない）、
かつ、str2 の j 番目の文字も存在する（つまり、ヌル文字でない）」ことを意味します。
この条件が真である限り、つまり両方の文字列の該当位置に文字が存在する限り、ループは続きます。

*   str1[i] && str2[j] の意味
str1[i]: str1 の i 番目の文字を指します。
この式が真を返すのは、str1[i] がヌル文字（文字列の終端を示す \0）でない場合です。

str2[j]: str2 の j 番目の文字を指します。
この式が真を返すのは、str2[j] がヌル文字でない場合です。
&&: 論理AND演算子で、左右の条件が両方とも真である場合にのみ真を返します。

str1[i] && str2[j] と str1[i] || str2[j] の違い
*　str1[i] || str2[j] では、|| は論理OR演算子です。

*この条件は、「str1 の i 番目の文字が存在する、または、str2 の j 番目の文字が存在する」ことを意味します。
つまり、二つの文字列のいずれかにまだ文字が残っていれば、条件は真となります。

つまり、str1[i] && str2[j] の場合は、両方の文字列の該当位置に文字が存在する場合にのみループが続行されますが、
str1[i] || str2[j] の場合は、どちらか一方の文字列に文字が存在すればループが続行されることになります。

この問題の文脈では、str1[i] && str2[j] は str1 の全ての文字が str2 に順序を維持して含まれるかをチェックするために使用されます。
str1[i] || str2[j] を使用すると、意図した動作にはならず、ロジックが正しく機能しないため、この場合には適していません。



*/