#include <stdio.h>
#include <stdlib.h>

typedef struct s_list t_list;

struct s_list
{
    int data;
    t_list* next;
};

int accending(int a, int b)
{
    return (a <= b);
}

t_list* sort_list(t_list* lst, int(*cmp)(int, int))
{
    int swap;
    t_list *tmp;
    
    tmp = lst;
    while (lst->next != 0)
    {
        if ((*cmp)(lst->data, lst->next->data) == 0)
        {
            swap = lst->data;
            lst->data = lst->next->data;
            lst->next->data = swap;
            lst = tmp;
        }
        else
            lst = lst->next;
    }
    lst = tmp;
    return (lst);
}

/* リストソート- while文内の分かりやすい説明


*リスト [3, 1, 2] 
が与えられた場合の while ループの動きを、
一切省略せずに詳細に説明します。

*初期状態:
リストは [3, 1, 2] です。
lst はリストの先頭（3を指している）を指します。
tmp もリストの先頭を指しています。

*1回目のループ:
比較: 3 と 1 を比較します。cmp(3, 1) は 0 を返します
（3 は 1 より大きいため、正しい順序ではありません）。

交換: 3 と 1 の位置を交換します。リストは [1, 3, 2] になります。

lst を tmp にリセット: lst をリストの先頭に戻します。lst は再び 1 を指します。

*2回目のループ:
比較: 1 と 3 を比較します。cmp(1, 3) は 1 を返します（1 は 3 より小さいため、正しい順序です）。

移動: 交換は行われません。lst は次の要素、つまり 3 を指すようになります。

*3回目のループ:
比較: 3 と 2 を比較します。cmp(3, 2) は 0 を返します（3 は 2 より大きいため、正しい順序ではありません）。

交換: 3 と 2 の位置を交換します。リストは [1, 2, 3] になります。

lst を tmp にリセット: lst をリストの先頭に戻します。lst は再び 1 を指します。

*4回目のループ:
比較: 1 と 2 を比較します。cmp(1, 2) は 1 を返します
（1 は 2 より小さいため、正しい順序です）。

移動: 交換は行われません。lst は次の要素、つまり 2 を指します。

*5回目のループ:
比較: 2 と 3 を比較します。
cmp(2, 3) は 1 を返します（2 は 3 より小さいため、正しい順序です）。

移動: 交換は行われません。lst は次の要素、つまり 3 を指します。
しかし、3 はリストの最後の要素なので、lst->next は NULL です。
これによりループは終了します。

*この時点で、リストは完全にソートされた状態 [1, 2, 3] になっています。
この詳細な説明からわかるように、lst はリストを通じて移動し、
隣接する要素間で必要に応じて交換を行います。

そして、交換が行われるたびに、
lst はリストの先頭にリセットされ、
ソートプロセスが完了するまでこのプロセスが繰り返されます。
*/


/*　関数宣言の解説


*戻り値
t_list *：この関数はt_list型のポインタを戻り値として返します。
t_listはstruct s_listのエイリアスで、リストの各ノードを表す構造体です。
この戻り値は、ソートされたリストの先頭ノードへのポインタを指します。

*引数

* t_list* lst：

t_list*はt_list型（struct s_listのエイリアス）のポインタです。
この引数lstは、ソートする必要のあるリストの先頭ノードへのポインタを表します。
関数はこのリストを操作し、ソートされたリストを返します。

* int (*cmp)(int, int)：

この引数は関数ポインタです。int (*cmp)は、関数ポインタの名前で、
この関数は2つのint型引数を取り、int型の値を返します。
この関数ポインタは比較関数を指し、リストをソートする際の基準を定義します。
例えば、2つの整数を比較してどちらが大きいか、または等しいかを判断し、
その結果に基づいてリストのノードを並び替えます。
関数の動作
この関数sort_listは、与えられたリストlstをソートし、
ソートされたリストの先頭へのポインタを返します。
ソートの方法（例えば、昇順または降順）は、
cmp関数ポインタを通じて提供された比較関数によって決定されます。
比較関数はリスト内の各要素（この場合は整数値）を比較し、
ソートプロセス中に要素の順序を決定します。

まとめ
この関数宣言は、リストのソートに関する一般的なアプローチを示しています。

ここで重要なのは、関数ポインタを使ってソートの条件（比較方法）
を柔軟に設定できることです。
これにより、同じソート関数を異なる条件下で再利用することが可能になります。

*/


/*  ノードについての分かりやすい解説


lst->next->dataは、C言語におけるリンクリストの要素にアクセスするための表現方法です。
ここで使用されているlstは、struct s_list型のポインタです。

この構造体は、少なくとも二つのフィールドを持っています

：int dataとt_list *next。dataフィールドは、
リストの各ノードに格納されるデータ（この場合は整数型）を保持し、
nextフィールドは次のノードへのポインタを保持します。

*具体的な説明

* lst: 
現在のノードを指すポインタです。

*lst->next: 
現在のノードのnextフィールドにアクセスします。

これは、リスト内の「次の」ノードへのポインタです。
つまり、lstがリストのある要素を指している場合、lst->nextはその要素の直後にある要素を指します。

*lst->next->data:
 lst->nextによって指されるノード、
 つまり次のノードのdataフィールドにアクセスします。
 これは、リストの次の要素に格納されているデータ（整数値）を意味します。
図解
リンクリストが以下のように連なっているとします：

[ノード1] -> [ノード2] -> [ノード3] -> ...

各ノードがdataとnextの二つのフィールドを持っているとすると、lstがノード1を指している場合：

lst->dataはノード1のデータを参照します。
lst->nextはノード2へのポインタです。
lst->next->dataはノード2のデータを参照します。

したがって、lst->next->dataを使用することで、
現在のノードの「次」のノードに格納されているデータ値にアクセスし、
それを取得または比較することができます。
リンクリストを扱う際には、このような表現を頻繁に使用します。




*リンクリストを列車にたとえると、考えてみましょう。
列車はたくさんの車両（ノード）がつながってできています。
lstは、列車の中の一つの車両を指していて、
その車両には番号が書いてあるかもしれません（これがdataです）。
そして、その車両は次の車両につながっています（これがnextです）。

lst->dataは、今見ている車両の番号です。
lst->nextは、今見ている車両の次につながっている車両を指します。
lst->next->dataは、今見ている車両の次にある車両の番号です。

もし、if ((*cmp)(lst->data, lst->next->data) == 0)というコードがあったら、
これは「今の車両の番号と次の車両の番号を比べて、同じかどうかを調べる」っていう意味です。
もし番号が同じなら、何か特別な処理をするかもしれません。
この比べる作業は、cmpという特別なルール（関数）で行います。

つまり、このコードは「列車の車両を順番に見ていき、
隣り合う二つの車両が同じ番号を持っているかどうかを調べる」ことをしているんだね。
*/



/*
このプログラムは、リンクリストをソートするためのものです。
以下にその処理の流れをステップごとに分かりやすく説明します。

*ステップ1: 準備
t_list という構造体を定義します。
これはリストの各要素（ノード）を表し、整数データ (int data) と次の要素へのポインタ (t_list* next) を持ちます。
ascending 関数は2つの整数を比較し、最初の数が2番目の数以下なら 1 を返し、そうでなければ 0 を返します。

*ステップ2: ソート関数の開始
sort_list 関数はリスト (lst) と、2つの整数を比較する関数へのポインタ (cmp) を引数として受け取ります。
ローカル変数 tmp にリストの先頭を指すポインタを保存しておきます。これにより、リストの先頭を失わずに済みます。

*ステップ3: リストの走査と要素の比較
リストを先頭から走査します。各ステップで現在の要素 (lst) と次の要素 (lst->next) を比較します。
cmp 関数を使って2つの要素を比較し、cmp が 0 を返した場合（つまり、要素が正しい順序にない場合）、
それらの要素を交換します。

*ステップ4: 要素の交換
要素を交換するには、まず swap 変数を使って一時的に現在の要素のデータを保存します。
次に、現在の要素 (lst->data) に次の要素のデータ (lst->next->data) を代入し、
保存しておいたデータ (swap) を次の要素に代入します。

*ステップ5: リストの先頭へのリセットと走査の続行
要素を交換した後、lst を tmp に戻してリストの先頭から再び走査を開始します。
これにより、リスト全体が正しい順序になるまで走査を繰り返します。
交換が不要な場合（cmp が 1 を返す場合）は、lst を次の要素に進めます。

*ステップ6: ソート完了
lst->next が NULL になると、リストの最後に達しています。
この時点で、全ての要素が正しい順序に並んでいるはずです。
最終的に、ソートされたリストの先頭へのポインタ (tmp) を返します。

このプログラムにより、リストは昇順（小さい数から大きい数へ）にソートされます。
プロセスは比較的単純で、リストを繰り返し走査し、
隣接する要素が正しい順序になるように要素を交換していきます。


*/