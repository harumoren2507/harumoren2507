#include <unistd.h>

void    last_word(char* str)
{
        int i;
        i = 0;
        while (str[i])
                i++;
        i -= 1;
        while (str[i] == ' ' || str[i] == '\t')
                i--;
        while (i >= 0)
        {
                if (str[i] == ' ' || str[i] == '\t')
                        break;
                i--;
        }
        i += 1;
        while (str[i] != '\0' && str[i] != ' ' && str[i] != '\t')
        {
                write(1, &str[i], 1);
                i++;
        }
}

int     main(int argc, char* argv[])
{
        if (argc == 2)
                last_word(argv[1]);
        write(1, "\n", 1);
}

/*
 *アプローチ整理

 まず、文字列が'\0'に達するまで、インクリメントする。

 現在 '\0'にいるので、+1してあげて、現在位置を文字列の最後にする。




*while( i >= 0)内の挙動

ご指摘の通り、while (i >= 0) ループ内で i が0の場合、ループの最初の繰り返しで i-- が実行され、i は-1になります。この挙動について説明します。

一文字だけの文字列 "a" の場合にこのコードがどう動くか、再度詳しく見てみましょう：

文字列 "a" を引数として last_word 関数が呼ばれ、i は文字列の長さから1を引いた値、つまり0に初期化されます（文字 'a' の位置）。

while (i >= 0) ループが開始されます。i が0の場合、この条件は真です。

ループ内で最初に if (str[i] == ' ' || str[i] == '\t') をチェックしますが、str[i] は 'a' なので、この条件は偽です。

次に i-- が実行され、i は-1になります。

ループの次の繰り返しでは、while (i >= 0) の条件が偽になるため、ループは終了します。

この時点で i が-1になるのは、実際には意図された動作です。なぜなら、この後に続くコードが最後の単語を出力する際に i を1増やして（i += 1;）、最後の単語の開始位置に戻すためです。この処理により、最後の単語の出力が開始されます。

-1になること自体が問題を引き起こすわけではありません。これは、最後の単語を探すアルゴリズムの一部として、最後の単語の開始位置を見つけるために必要なステップです。プログラムはこの-1の状態を適切に処理し、結果として正しい最後の単語を出力します。

この説明で、i が-1になることに対する疑問が解消されたことを願います。




*while(str[i]) とwhile (*str)の違いについて
はい、その通りです。str[i]を使用する場合とwhile(*str)を使う場合では、文字列を走査する際のポインタの挙動が異なります。これらの違 いを明確に説明します。

str[i]を使用した場合
str[i]を使った場合、iをインデックスとして使い、文字列の特定の位置にアクセスします。この方法では、ポインタstr自体は移動しません。代わりに、インデックスiを増減させることにより文字列内を移動します。
ループでstr[i]を使う例は以下の通りです：

int i = 0;
while (str[i]) {
    i++; // インデックスを次の文字に進める
}
この場合、iを0から始めて文字列の各文字に順番にアクセスし、ヌル文字'\0'に到達するまでiを増加させ続けます。

while(*str)を使用した場合
while(*str)を使用する場合、ループの各繰り返しでポインタstr自体を文字列の次の文字へと移動させます。この方法では、インデックスを使わずにポインタの指すアドレスを直接変更して文字列を走査します。
ループでwhile(*str)を使う例は以下の通りです：

while (*str) {
    str++; // ポインタを次の文字に進める
}
この場合、*strは現在ポインタが指す文字を参照し、str++によりポインタ自体が文字列の中で次の文字へ移動します。ポインタがヌル文字'\0'を指すと、ループは終了します。

挙動の違い
ポインタの移動: while(*str)はポインタstrを実際に移動させますが、str[i]ではポインタは固定され、インデックスiのみが変化します。
アクセス方法: while(*str)はポインタ演算を使って現在の文字にアクセスします。str[i]は配列のインデックスを通じて文字にアクセスしま す。
可読性と利便性: while(*str)は文字列の終端に達するまでの走査をシンプルに表現できますが、特定の位置にアクセスしたい場合や複数の位 置を同時に追跡したい場合はstr[i]の方が適している場合があります。
どちらの方法を選ぶかは、実装したいロジックや操作の性質によって異なります。
*/
