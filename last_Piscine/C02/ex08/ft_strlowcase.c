/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlowcase.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: harumoren2507 <kuroshiro0725@gmail.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/01/22 21:44:40 by harumoren25       #+#    #+#             */
/*   Updated: 2024/01/24 23:38:36 by harumoren25      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <stdio.h>
char *ft_strlowcase(char *str)
{
    int i;
    i = 0;

    while (str[i] != '\0')
    {
        if (str[i] >= 'A' && str[i] <= 'Z') 
        {
            str[i] += 32;
        }
        i++;
    }
    return (str);
}


int main(void)
{
    char str[] = "ABCDEFG";
    printf("%s\n", ft_strlowcase(str));
    return (0);
}

/*

なぜ以下の例でセグフォが起こるのか
int main(void)
{
    printf("%s\n", ft_strlowcase("ABCDEF"));
}


*なぜセグメンテーションフォルトが起こるのか
あなたのプログラムでは、ft_strlowcase 関数に
リテラル文字列 "ABCDEF" を直接渡しています。

この文字列は読み取り専用メモリにあるため、
関数内で文字列を変更しようとすると、
プログラムはセグメンテーションフォルトを引き起こします。

*どのような時にリテラル文字列が
*読み取り専用のメモリ領域に配置に配置されるのか

リテラル文字列が読み取り専用のメモリ領域に配置される場合は、
基本的に文字列が直接プログラムのコード内に埋め込まれるときです。

以下例:

*1. 直接文字列を使用する場合

printf("Hello, World!");
この例では、"Hello, World!" はリテラル文字列で、
読み取り専用メモリに配置されます。

*2. ポインタを使ってリテラル文字列を指す場合

const char *str = "Example";
ここでは str はリテラル文字列 "Example" を指しています。
この文字列は読み取り専用メモリに配置されます。

*3. 配列の初期化にリテラル文字列を使用する場合

char str[] = "Array";
この場合、"Array" はリテラル文字列ですが、
それは str という配列にコピーされます。

ここでのリテラル文字列は読み取り専用メモリに配置されますが、
str 配列自体は変更可能です。

*/