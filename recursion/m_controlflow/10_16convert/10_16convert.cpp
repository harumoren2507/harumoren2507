#include <iostream>
#include <string>
#include <cmath>

using namespace std;

string decimalToHexadecimal(int decNumber) 
{
    // 基底ケース: decNumberが0のときは空の文字列を返す
    if (decNumber == 0)
        return  "";
    else
    {
        int reminder = decNumber % 16;
        string hexChar;
        if (reminder < 10)
            hexChar = to_string(reminder);
        else
            hexChar = 'A' + (reminder - 10);
        return decimalToHexadecimal(decNumber / 16) + hexChar;
    }
}


/*
もっと簡単な説明
*10進数って何？: 普段使っている数字。0から9まで。
*16進数って何？: コンピューターが好きな数字。0から9の後に、AからFが来る。Aは10、Bは11...と続く。

変換方法: 数字を16で割って、余りを見る。余りがそのまま16進数の数字になる。
商も同じように16で割っていく。もう割れなくなったら、その数字が最後の数字。

*お話しバージョン
「森の中で、26匹のリスがいました。
リスたちは、16匹ずつのグループに分かれたいと思っていました。

26匹を数えてみると、ちょうど1グループに16匹と、余りで10匹が出てきました。

しかし、リスたちは特別で、余りの10匹を"A"と呼ぶことにしました。
そして、1グループと"A"匹のリスで、"1A"という新しい名前のグループができたのです。」
*/

/* 
hexChar = 'A' + (remainder - 10);の行は、10進数を16進数に変換する際のロジックの一部で、10以上の余りを16進数の文字（'A'から'F'）に変換するために使用されます。この式の背後にあるロジックを詳しく説明します。

16進数では、数値は0から15までを使用して表され、10から15まではそれぞれ'A'から'F'の文字で表されます。具体的には、10が'A'、11が'B'、12が'C'、13が'D'、14が'E'、15が'F'となります。

ロジックの理解
remainder変数は、現在処理している10進数の数値を16で割った余りを保持しています。
余りが10以上の場合、それは16進数で'A'から'F'に対応する必要があります。
'A'の文字コードは65（ASCIIコードにおける'A'の値）であり、10進数の10を16進数の'A'に変換するには、'A'からのオフセットとして10を引く必要があります。
式の解説
remainder - 10は、余りから10を引くことで、10〜15の余りを0〜5の範囲にマッピングします。
'A' + (remainder - 10)は、この0〜5の範囲を'A'〜'F'の範囲にマッピングします。これは、'A'の文字コードに0〜5を加算することで、対応する16進数の文字を得るためです。
例えば、余りが10の場合:

10 - 10は0です。
'A' + 0は'A'です（'A'は10進数で16進数において10を意味します）。
余りが15の場合:

15 - 10は5です。
'A' + 5は'F'です（'F'は10進数で16進数において15を意味します）。
このロジックにより、10から15までの任意の10進数の余りを、適切な16進数の文字に変換することができます。

*/